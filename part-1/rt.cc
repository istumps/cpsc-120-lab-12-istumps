// Isaac Stumps
// CPSC 120-18
// 2021-12-6
// istumps@csu.fullerton.edu
// @istumps
//
// Lab 12-01
//
// Program to make a dynamic image using vectors
//
/// \file

#include <Magick++.h>

#include <cassert>
#include <chrono>
#include <iostream>
#include <string>
#include <vector>

#include "rng.h"

using namespace std;
using namespace Magick;

/// Check to see if \p filename ends with the extension \p extension.
/// \param filename A string that represents a file name
/// \param extension An extension such as ".txt" or ".gif"
/// \returns True if \p filename ends with \p extension, False otherwise
bool HasFileExtension(const string &filename, const string &extension) {
  return filename.size() >= extension.size() &&
         filename.compare(filename.size() - extension.size(), extension.size(),
                          extension) == 0;
}

/// Return a True or False depending on a random value.
/// Generates a random number and then decides to return True or False
bool CoinFlip() { return RandomDouble_11() > 0.0; }
/// Main function - Entry point for our ray tracer
/// The program takes two arguments which is the output file name and a
/// a brief message. The image generated by the main function is written
/// out as a GIF file.
int main(int argc, char const *argv[]) {
  InitializeMagick(*argv);

  vector<string> args = vector<string>(argv, argv + argc);

  string output_file_name;
  string message;
  try {
    output_file_name = (args.at(1));
    message = (args.at(2));
  } catch (exception const &problem) {
    cout << "Ran into problem getting the arguments. \n";
    cout << problem.what() << "\n";
    return 1;
  }
  // Check to make sure the user specified a GIF/gif file.
  if (not HasFileExtension(output_file_name, ".gif") &&
      not HasFileExtension(output_file_name, ".GIF")) {
    cout << "Please provide an output file name that ends in '.gif' or '.GIF'. "
            "Exiting.\n";
    exit(1);
  }

  /// The image is the output from the virtual camera. The image is what
  /// you will see when you open the output in an image viewer. The image's
  /// dimensions are specified in pixels and are therefore in integer units.
  /// The aspect ratio represents the ratio of width / height. The ratio
  /// 16:9 is the ratio used for wide format movies. Traditional 35mm film
  /// photographs have an image that is 36 mm x 24 mm which has an aspect
  /// ratio of 36:24 or 1.5.
  const double kAspectRatio = 16.0 / 9.0;
  // Set the image width to 400 pixels
  const int kImageWidth = 512;
  // Calculate the height of the image using the width and aspect ratio.
  // Remember to round the number to the closest integer.
  const int kImageHeight = int(lround(kImageWidth / kAspectRatio));
  // Create a new Image object using the file name provided on the
  // command line.
  ColorRGB yellow(1, 1, 0);
  // Create a yellow image the size that we'd like. Use yellow or some
  // obviously wrong color (a color not in our image)to help us debug
  // our output.
  Image image(Geometry(kImageWidth, kImageHeight), yellow);
  // Print out some information about the image to help us debug what's
  // going on.
  cout << "Your image has " << image.columns() << " columns (x direction) and "
       << image.rows() << " rows (y direction).\n";

  const int kNumberOfImages = 10;
  // This vector will store each frame of our animated GIF.
  vector<Image> images;

  // Save the starting time so the elapsed time can
  // be calculated.
  chrono::time_point<chrono::high_resolution_clock> start =
      chrono::high_resolution_clock::now();

  for (int images_counter = 0; images_counter < kNumberOfImages;
       images_counter++) {
    for (int column = 0; column < image.columns(); column++) {
      for (int row = 0; row < image.rows(); row++) {
        assert(row < image.rows());
        assert(column < image.columns());

        double random_color_intensity = RandomDouble_01();
        double red = 0.0;
        double green = 0.0;
        double blue = 0.0;

        if (CoinFlip()) {
          red = random_color_intensity;
        }
        if (CoinFlip()) {
          green = random_color_intensity;
        }
        if (CoinFlip()) {
          blue = random_color_intensity;
        }

        ColorRGB pixel_color(red, green, blue);
        image.pixelColor(column, row, pixel_color);
      }
    }
    image.font("Helvetica");
    image.fontPointsize(72);
    image.fillColor(Color("yellow"));
    image.annotate(message, CenterGravity);
    // push the image into the vector named images
    images.push_back(image);
  }
  chrono::time_point<chrono::high_resolution_clock> end =
      chrono::high_resolution_clock::now();

  writeImages(images.begin(), images.end(), output_file_name);
  // Calculate the elapsed time by taking the difference between end
  // and start.
  chrono::duration<double> elapsed_seconds = end - start;

  // Display the elapsed number of seconds.
  cout << "Time elapsed: " << elapsed_seconds.count() << " seconds.\n";

  return 0;
}
